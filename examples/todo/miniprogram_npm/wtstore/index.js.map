{"version":3,"sources":["index.js","schedules.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["const { queueStore } =  require(\"./schedules\")\n\nconst OBJECT_TYPE = '[object Object]'\nconst ARRAY_TYPE = '[object Array]'\nconst FUNCTION_TYPE = '[object Function]'\n\nlet uid = 0\n\nlet noop = function(){}\n\nconst clone = require('rfdc')()\n\nconst p = Promise.resolve(1)\n\n// 微任务调度器\nconst microTask = (fn) => {\n    p.then(fn)\n}\n\nclass Store {\n\n    constructor() {\n        this.id = ++uid\n        this._data = {}\n        this._preData = {}\n        this._views = []\n        this._hasViews = new Map()\n        this._callback = noop\n    }\n\n    bind(key, view) {\n        if(this._hasViews.has(view)) return Error(\"The same store and view cannot be bound repeatedly\")\n        this._views.push({\n            key,\n            view\n        })\n        view.data[key] = this.data\n        this.render(view, key, this.data)\n    }\n\n    update(callback) {\n        if(callback) {this._callback = callback}\n        queueStore(this)\n    }\n\n    remove(view) {\n        this._views = this._views.filter(item => {\n            return item.view != view\n        })\n    }\n\n    run() {\n        const patch = this.diffData(this.data, this._preData, '')\n        let promises = []\n        this._views.forEach(item => {\n            promises.push(this.render(item.view, item.key, patch))\n        })\n        // 所有UI数据更新完成之后执行回调\n        Promise.allSettled(promises).then(this._callback)\n        // 通过微任务做深拷贝，可以更早将渲染数据发送至渲染层\n        microTask(() => {\n            this._preData = clone(this.data)\n        })\n    }\n\n    render(view, path, patch) {\n        return new Promise((resolve) => {\n            const relPatch = this.splicePatch(path, patch)\n            view.setData(relPatch, resolve)\n        })\n    }\n\n    splicePatch(path, patch) {\n        let result = {}\n        Object.keys(patch).forEach(key => {\n            result[`${path}.${key}`] = patch[key]\n        })\n        return result\n    }\n\n    diffData(curr, pre, path = '') {\n        if(!pre) pre = {}\n        this.syncKeys(curr, pre)\n        let result = {}\n        this.diff(curr, pre, path, result)\n        return result\n    }\n\n    syncKeys(curr, previous) {\n        const currType = this.getType(curr)\n        const previousType = this.getType(previous)\n        if(currType === OBJECT_TYPE && previousType === OBJECT_TYPE) {\n            for(let key in previous) {\n                let previousValue = previous[key]\n                if(curr[key] === undefined) {\n                    curr[key] = null\n                }\n                let currValue = curr[key]\n                this.syncKeys(currValue, previousValue)\n            }\n        }else if(currType === ARRAY_TYPE && previousType === ARRAY_TYPE) {\n            previous.forEach((item, index) => {\n                this.syncKeys(curr[index], item)\n            });\n        }\n    }\n\n    diff(curr, previous, path, result) {\n        const currType = this.getType(curr)\n        const previousType = this.getType(previous)\n        if(curr === previous) {\n            return\n        }else if(currType === OBJECT_TYPE && previousType === OBJECT_TYPE) {\n            for(let key in curr) {\n                this.diff(curr[key], previous[key], this.setPath(path, key), result)\n            }\n        }else if(currType === ARRAY_TYPE && previousType === ARRAY_TYPE) {\n            if(previous.length > curr.length) {\n                this.setResult(result, path, curr)\n            }else { \n                curr.forEach((item, index) => {\n                    this.diff(item, previous[index], this.setPath(path, index), result)\n                })\n            }\n        }else {\n            // 收集结果\n            this.setResult(result, path, curr)\n        }\n    }\n\n    /**\n     * 将this.data的数据挂载到this上\n     */\n    proxyData() {\n        Object.keys(this.data).forEach(key => {\n            Object.defineProperty(this, key, {\n                configurable: true,\n                enumerable: true,\n                get() {\n                    return this.data[key]\n                },\n                set(value) {\n                    this.data[key] = value\n                }\n            })\n        })\n    }\n\n    getType(obj) {\n        return Object.prototype.toString.call(obj)\n    }\n\n    setPath(path, key) {\n        if(typeof key === 'number') {\n            return `${path}[${key}]`\n        }else {\n            return path ? `${path}.${key}` : key\n        }\n    }\n\n    setResult(result, k, v) {\n        if(typeof v !== FUNCTION_TYPE) {\n            result[k] = v\n        }\n    }\n\n    get data() {\n        return this._data\n    }\n\n    // 防止引用地址被非法篡改\n    set data(obj) {\n        if(!obj || this.getType(obj) !== OBJECT_TYPE) {\n            throw new Error('The right value must be a valid object.')\n        }\n        Object.assign(this._data, obj)\n        this.proxyData()\n    }\n}\n\nmodule.exports = Store\n","\nlet queue = []\n\nlet has = {}\n\nlet pending = false\n\nconst p = Promise.resolve()\n\nfunction flushSchedulerQueue() {\n    for(let i = 0; i< queue.length; i++) {\n        queue[i].run()\n    }\n    has = {}\n    queue = []\n    pending = false\n}\n\nexports.queueStore = function(store) {\n    let id = store.id\n    if(has[id]) {\n        return\n    }\n    has[id] = true\n    queue.push(store)\n    if(!pending) {\n        pending = true\n        p.then(flushSchedulerQueue)\n    }\n}"]}