{"version":3,"sources":["index.js","schedules.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["const { queueStore } =  require(\"./schedules\")\r\n\r\nconst OBJECT_TYPE = '[object Object]'\r\nconst ARRAY_TYPE = '[object Array]'\r\nconst FUNCTION_TYPE = '[object Function]'\r\n\r\nlet uid = 0\r\n\r\nlet noop = function(){}\r\n\r\nconst clone = require('rfdc')()\r\n\r\nclass Store {\r\n\r\n    constructor() {\r\n        this.id = ++uid\r\n        this._data = {}\r\n        this._views = []\r\n        this._hasViews = new Map()\r\n        this._callback = noop\r\n    }\r\n\r\n    bind(key, view) {\r\n        if(this._hasViews.has(view)) return Error(\"The same store and view cannot be bound repeatedly\")\r\n        this._views.push({\r\n            key,\r\n            view\r\n        })\r\n        view.data[key] = this.data\r\n        view._preData = (view._preData ? view._preData : {})\r\n        this.render(view, key)\r\n    }\r\n\r\n    update(callback) {\r\n        if(callback) {this._callback = callback}\r\n        queueStore(this)\r\n    }\r\n\r\n    remove(view) {\r\n        this._views = this._views.filter(item => {\r\n            return item.view != view\r\n        })\r\n    }\r\n\r\n    run() {\r\n        let promises = []\r\n        this._views.forEach(item => {\r\n            promises.push(this.render(item.view, item.key))\r\n        })\r\n        // 所有UI数据更新完成之后执行回调\r\n        Promise.allSettled(promises).then(this._callback)\r\n    }\r\n\r\n    render(view, path) {\r\n        return new Promise((resolve) => {\r\n            const patch = this.diffData(view.data[path], view._preData[path], path)\r\n            view.setData(patch, resolve)\r\n            // 深克隆可以进行优化，diff的时候就能进行数据的变更修改\r\n            view._preData[path] = clone(view.data[path])\r\n        })\r\n    }\r\n\r\n    diffData(curr, pre, path = '') {\r\n        if(!pre) pre = {}\r\n        this.syncKeys(curr, pre)\r\n        let result = {}\r\n        this.diff(curr, pre, path, result)\r\n        return result\r\n    }\r\n\r\n    syncKeys(curr, previous) {\r\n        const currType = this.getType(curr)\r\n        const previousType = this.getType(previous)\r\n        if(currType === OBJECT_TYPE && previousType === OBJECT_TYPE) {\r\n            for(let key in previous) {\r\n                let previousValue = previous[key]\r\n                if(curr[key] === undefined) {\r\n                    curr[key] = null\r\n                }\r\n                let currValue = curr[key]\r\n                this.syncKeys(currValue, previousValue)\r\n            }\r\n        }else if(currType === ARRAY_TYPE && previousType === ARRAY_TYPE) {\r\n            previous.forEach((item, index) => {\r\n                this.syncKeys(curr[index], item)\r\n            });\r\n        }\r\n    }\r\n\r\n    diff(curr, previous, path, result) {\r\n        const currType = this.getType(curr)\r\n        const previousType = this.getType(previous)\r\n        if(curr === previous) {\r\n            return\r\n        }else if(currType === OBJECT_TYPE && previousType === OBJECT_TYPE) {\r\n            for(let key in curr) {\r\n                this.diff(curr[key], previous[key], this.setPath(path, key), result)\r\n            }\r\n        }else if(currType === ARRAY_TYPE && previousType === ARRAY_TYPE) {\r\n            if(previous.length > curr.length) {\r\n                this.setResult(result, path, curr)\r\n            }else { \r\n                curr.forEach((item, index) => {\r\n                    this.diff(item, previous[index], this.setPath(path, index), result)\r\n                })\r\n            }\r\n        }else {\r\n            // 收集结果\r\n            this.setResult(result, path, curr)\r\n        }\r\n    }\r\n\r\n    getType(obj) {\r\n        return Object.prototype.toString.call(obj)\r\n    }\r\n\r\n    setPath(path, key) {\r\n        if(typeof key === 'number') {\r\n            return `${path}[${key}]`\r\n        }else {\r\n            return path ? `${path}.${key}` : key\r\n        }\r\n    }\r\n\r\n    setResult(result, k, v) {\r\n        if(typeof v !== FUNCTION_TYPE) {\r\n            result[k] = v\r\n        }\r\n    }\r\n\r\n    get data() {\r\n        return this._data\r\n    }\r\n\r\n    // 防止引用地址被非法篡改\r\n    set data(obj) {\r\n        if(!obj || this.getType(obj) !== OBJECT_TYPE) {\r\n            throw new Error('The right value must be a valid object.')\r\n        }\r\n        Object.assign(this._data, obj)\r\n    }\r\n}\r\n\r\nmodule.exports = Store\r\n","\r\nlet queue = []\r\n\r\nlet has = {}\r\n\r\nlet pending = false\r\n\r\nconst p = Promise.resolve()\r\n\r\nfunction flushSchedulerQueue() {\r\n    for(let i = 0; i< queue.length; i++) {\r\n        queue[i].run()\r\n    }\r\n    has = {}\r\n    queue = []\r\n    pending = false\r\n}\r\n\r\nexports.queueStore = function(store) {\r\n    let id = store.id\r\n    if(has[id]) {\r\n        return\r\n    }\r\n    has[id] = true\r\n    queue.push(store)\r\n    if(!pending) {\r\n        pending = true\r\n        p.then(flushSchedulerQueue)\r\n    }\r\n}"]}